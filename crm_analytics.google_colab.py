# -*- coding: utf-8 -*-
"""CRM Analytics

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Bl95KWTw83zEGmYRd48TeqSDtBbsw65b

# **CRM Analytics**

# **1 Contexto**

Nos últimos anos, o e-commerce tem transformado a forma como os consumidores interagem com empresas e realizam compras. O aumento da competitividade nesse setor exige estratégias baseadas em dados para melhorar a experiência do cliente, aumentar a retenção e impulsionar a receita.

O objetivo deste projeto foi analisar dados transacionais de um e-commerce, identificando padrões no comportamento dos consumidores e criando métricas úteis, como RFM (Recency, Frequency, Monetary) e CLV (Customer Lifetime Value), para orientar decisões estratégicas. Com essas análises, foi possível avaliar a retenção de clientes, os produtos mais populares, os clientes mais valiosos e as tendências de vendas ao longo do tempo.

Este estudo oferece um caminho claro para implementar ações baseadas em dados que podem melhorar o desempenho do negócio e fortalecer o relacionamento com os clientes.

# **2. Bibliotecas**
"""

# Importar bibliotecas utilizadas no projeto

# Manipulação e análise de dados tabulares
import pandas as pd

# Suporte para operações numéricas e arrays
import numpy as np

# Criação de gráficos e visualizações simples
import matplotlib.pyplot as plt

# Visualizações estatísticas avançadas
import seaborn as sns

# (Opcional) Detectar a codificação de arquivos CSV
import chardet

# (Opcional) Operações matemáticas e estatísticas avançadas
from scipy import stats

"""# **3. download do arquivo**"""

# Baixar o arquivo
!wget -O data.zip "https://storage.googleapis.com/kaggle-data-sets/1985/3404/compressed/data.csv.zip?X-Goog-Algorithm=GOOG4-RSA-SHA256&X-Goog-Credential=gcp-kaggle-com%40kaggle-161607.iam.gserviceaccount.com%2F20241118%2Fauto%2Fstorage%2Fgoog4_request&X-Goog-Date=20241118T085957Z&X-Goog-Expires=259200&X-Goog-SignedHeaders=host&X-Goog-Signature=89386d347882563cd0e934a6c42ac39e2e32a9efceadb39d5dfb5d6bd9cca4f16426ac633ce7e4d128f043b95ed4a84c2c968b4a9807c13edbe38662e73650e70018aab80b639111b0b844b24321fdda9a32f57857be24bb733f060c82f82adb941006364629ebbc3296775ef4f3592b4bcaa5f26976263ef3b70116ab7487430263e537ea85d515e8a61407bedecf0639511db17cfa519fffab5312934e9aa160bc463f9b03de9de6eddb26a5b16e4a6e4ae907c303bacde33961c3dd9a2e1dbb323974ec8ce8094c06a82b0191ed642480f00e0ce6f1135d0c95d99b0a4da99eabf755c6865b048bfcf00e17d0ac84b625e0cfcc512e302640e4d8bf1e499c"

# Descompactar o arquivo baixado
!unzip data.zip -d ./data

"""## **3.1 Carregando a base de dados**"""

import pandas as pd

# Caminho para o arquivo
file_path = '/content/data/data.csv'

# Carregar o arquivo CSV com especificação de codificação
# Experimente com 'latin1', 'ISO-8859-1', ou 'cp1252' se 'utf-8' não funcionar
df = pd.read_csv(file_path, encoding='latin1')

# Exibir as primeiras linhas do dataframe
df.head()

"""# **4. Pré-processamento dos Dados**

**Descrição:** Antes de realizar análises avançadas, é essencial garantir que os dados estejam limpos e consistentes. Essa etapa remove informações redundantes ou inválidas e prepara o dataset para análises mais profundas, como agrupamentos ou cálculos de métricas relevantes.
"""

# Converter a coluna InvoiceDate para datetime
df['InvoiceDate'] = pd.to_datetime(df['InvoiceDate'], errors='coerce')

# Remover duplicados
df = df.drop_duplicates()

# Remover registros com valores negativos ou zero
df = df[df['Quantity'] > 0]
df = df[df['UnitPrice'] > 0]

# Preencher valores ausentes (exemplo: preencher CustomerID com 'Unknown')
df['CustomerID'] = df['CustomerID'].fillna('Unknown')

# Criar novas colunas
df['YearMonth'] = df['InvoiceDate'].dt.to_period('M')  # Extrair ano e mês
df['Revenue'] = df['Quantity'] * df['UnitPrice']       # Calcular receita

df.head()

"""# **5. Compreensão dos Dados**

## **5.1. Produtos Mais Vendidos**

**Descrição:**
Este código busca identificar os produtos mais populares entre os clientes. Entender quais itens têm maior demanda é essencial para otimizar o estoque, priorizar esses produtos em campanhas promocionais e aumentar as vendas.
"""

# Produtos mais vendidos
top_products = df.groupby('Description')['Quantity'].sum().sort_values(ascending=False).head(10)
top_products.head()

"""## **5.2. Receita Total por Transação e Clientes Mais Lucrativos**

**Descrição:**

**Receita Total por Transação:** É necessário calcular quanto cada transação gerou de receita para identificar o impacto de cada cliente ou produto.

**Clientes Mais Lucrativos:** Entender quais clientes geram a maior parte da receita é fundamental para estratégias de retenção, fidelidade e campanhas personalizadas.
"""

# Criar a coluna 'TotalPrice' (Receita Total por Transação)
df['TotalPrice'] = df['Quantity'] * df['UnitPrice']

# Clientes mais lucrativos
top_customers = df.groupby('CustomerID')['TotalPrice'].sum().sort_values(ascending=False).head(10)

# Exibir os clientes mais lucrativos
top_customers.head()

"""## **5.3. Receita Total por Dia**

**Descrição:** Monitorar a receita total diária ajuda a identificar padrões de sazonalidade, picos de vendas e períodos de baixa demanda. Essas informações permitem que a empresa planeje campanhas promocionais nos momentos certos e gerencie o estoque de forma eficiente.
"""

import matplotlib.pyplot as plt

# Receita total por dia
df['TotalPrice'] = df['Quantity'] * df['UnitPrice']
df['InvoiceDate'] = pd.to_datetime(df['InvoiceDate'])
df['InvoiceDateOnly'] = df['InvoiceDate'].dt.date

sales_per_day = df.groupby('InvoiceDateOnly')['TotalPrice'].sum()

# Visualizar vendas por dia
plt.figure(figsize=(12, 6))
sales_per_day.plot()
plt.title('Receita Total por Dia')
plt.xlabel('Data')
plt.ylabel('Receita')
plt.grid()
plt.show()

"""**Insights**

1. **Sazonalidade e Picos de Vendas:**

* Se o gráfico apresenta picos regulares em determinados períodos (ex.: finais de semana, datas próximas a feriados ou eventos promocionais), isso sugere sazonalidade no comportamento dos consumidores.

* Esses picos indicam momentos de alta demanda e podem ser aproveitados para campanhas futuras.


2. **Tendência de Receita:**

* Uma linha ascendente no gráfico indica crescimento nas vendas ao longo do tempo, sugerindo aumento no engajamento dos clientes ou eficácia de estratégias de marketing.

* Uma linha descendente pode indicar queda nas vendas, que deve ser investigada para identificar problemas, como perda de clientes ou baixa eficácia de campanhas.

3. I**mpacto de Eventos Promocionais:**

* Picos abruptos podem estar associados a promoções, lançamentos de produtos ou campanhas publicitárias. Monitorar essas datas ajuda a avaliar o impacto de ações de marketing.

4. **Datas de Baixa Receita:**

* Períodos com quedas significativas na receita (ex.: feriados prolongados ou finais de mês) podem indicar sazonalidade negativa, onde as vendas são naturalmente menores.

* Esses períodos podem ser utilizados para planejar promoções ou estratégias de reativação.

# **6. Análise RFM**

## **6.1. Cálculo de Recency, Frequency e Monetary**

**Descrição:** A análise RFM permite segmentar os clientes com base em Recency (tempo desde a última compra), Frequency (frequência de compras) e Monetary (valor gasto). Essa análise é fundamental para priorizar ações de marketing e entender o comportamento do cliente.
"""

# Calcular Recency, Frequency e Monetary
snapshot_date = df['InvoiceDate'].max() + pd.Timedelta(days=1)
rfm = df.groupby('CustomerID').agg({
    'InvoiceDate': lambda x: (snapshot_date - x.max()).days,  # Recency
    'InvoiceNo': 'count',  # Frequency
    'Revenue': 'sum'  # Monetary
}).rename(columns={
    'InvoiceDate': 'Recency',
    'InvoiceNo': 'Frequency',
    'Revenue': 'Monetary'
})

rfm.describe().head()

"""## **6.2. Classificação dos Clientes**

**Descrição:** A classificação permite criar um sistema de pontuação para identificar diferentes segmentos de clientes. O objetivo é priorizar ações com base nos grupos de clientes, como VIPs ou aqueles em risco de churn.
"""

# Calcular Recency, Frequency e Monetary
snapshot_date = df['InvoiceDate'].max() + pd.Timedelta(days=1)
rfm = df.groupby('CustomerID').agg({
    'InvoiceDate': lambda x: (snapshot_date - x.max()).days,  # Recency
    'InvoiceNo': 'count',  # Frequency
    'Revenue': 'sum'  # Monetary
}).rename(columns={
    'InvoiceDate': 'Recency',
    'InvoiceNo': 'Frequency',
    'Revenue': 'Monetary'
})

# Classificar os clientes com base no RFM
rfm['R'] = pd.qcut(rfm['Recency'], 4, labels=[4, 3, 2, 1])
rfm['F'] = pd.qcut(rfm['Frequency'], 4, labels=[1, 2, 3, 4])
rfm['M'] = pd.qcut(rfm['Monetary'], 4, labels=[1, 2, 3, 4])
rfm['RFM_Score'] = rfm[['R', 'F', 'M']].sum(axis=1)

rfm.head()

"""## **6.3. Visualização da Análise RFM**

Descrição: Podemos criar um gráfico para visualizar a segmentação dos clientes com base no RFM_Score. Um gráfico de barras, por exemplo, ajudará a entender a distribuição dos clientes em diferentes segmentos.
"""

import matplotlib.pyplot as plt

# Contar o número de clientes por pontuação RFM
rfm_score_counts = rfm['RFM_Score'].value_counts().sort_index()

# Criar o gráfico de barras
plt.figure(figsize=(10, 6))
rfm_score_counts.plot(kind='bar', color='skyblue', edgecolor='black')
plt.title('Distribuição dos Clientes por Pontuação RFM', fontsize=14)
plt.xlabel('Pontuação RFM', fontsize=12)
plt.ylabel('Número de Clientes', fontsize=12)
plt.xticks(rotation=0)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

"""**Insights**

1. **Distribuição Geral:**

* Se houver uma concentração significativa de clientes em escores mais altos (ex.: 10, 11 ou 12), significa que há uma base sólida de clientes engajados e valiosos, que compram frequentemente e gastam muito.

* Se a maioria dos clientes estiver concentrada em escores baixos (ex.: 3, 4 ou 5), pode indicar que o negócio tem muitos clientes inativos ou de baixo valor.

2. **Identificação de Clientes Valiosos:**

* Clientes com escores RFM altos (como 11 ou 12) são os mais valiosos. Esses clientes devem ser priorizados em estratégias de retenção e fidelidade, como programas de recompensas ou campanhas personalizadas.

3. **Segmentos em Risco:**

* Clientes com escores baixos (ex.: 3 ou 4) podem representar clientes que não compram há muito tempo, têm baixa frequência de compra ou gastam pouco. Esses clientes estão em risco de churn e podem precisar de campanhas de reativação.

4. **Estratégias de Crescimento:**

* Se a distribuição é muito desigual, com poucos clientes nos escores mais altos, é uma oportunidade de melhorar o engajamento e aumentar a retenção, incentivando clientes de escores médios a subir para escores maiores.

# **7. Análise de Coorte**

## **7.1. Cálculo da Tabela de Retenção**

**Descrição:** A análise de coorte permite entender como os clientes, agrupados com base no mês de aquisição, se comportam ao longo do tempo. Essa abordagem é usada para avaliar a retenção de clientes, o que ajuda a identificar problemas ou sucessos em engajamento e fidelidade.
"""

import pandas as pd

# Passo 1: Carregar os dados
file_path = '/content/data/data.csv'  # Caminho fornecido
df = pd.read_csv(file_path, encoding='latin1')

# Passo 2: Converter a data para datetime
df['InvoiceDate'] = pd.to_datetime(df['InvoiceDate'], errors='coerce')  # Tratar erros de conversão

# Remover registros com InvoiceDate ausente ou CustomerID ausente
df = df.dropna(subset=['InvoiceDate', 'CustomerID'])

# Garantir que CustomerID seja inteiro
df['CustomerID'] = df['CustomerID'].astype(int)

# Passo 3: Criar o Mês da Coorte (primeiro mês de compra de cada cliente)
df = df.assign(CohortMonth=df.groupby('CustomerID')['InvoiceDate'].transform('min').dt.to_period('M'))

# Passo 4: Criar o índice da coorte (número de meses desde a coorte)
df = df.assign(CohortIndex=(df['InvoiceDate'].dt.to_period('M') - df['CohortMonth']).apply(
    lambda x: x.n if pd.notnull(x) else None
))

# Remover valores inconsistentes após a criação do índice
df = df.dropna(subset=['CohortIndex'])

# Passo 5: Agrupar por CohortMonth e CohortIndex para calcular o número de clientes únicos
cohort_data = df.groupby(['CohortMonth', 'CohortIndex'])['CustomerID'].nunique().unstack(0)

# Passo 6: Calcular a taxa de retenção
cohort_size = cohort_data.iloc[0]  # Tamanho inicial da coorte
retention = cohort_data.divide(cohort_size, axis=1)

# Exibir apenas a tabela de retenção
retention.head()

"""## **7.2. Visualização da Retenção com Heatmap**

**Descrição:** O heatmap fornece uma representação visual clara da retenção, mostrando como cada grupo de clientes (coorte) se comporta ao longo do tempo. Ele facilita a identificação de tendências e outliers.
"""

# Passo 8: Criar o Heatmap para Visualizar a Retenção
plt.figure(figsize=(12, 8))
plt.title('Análise de Retenção')
sns.heatmap(retention, annot=True, fmt='.0%', cmap='coolwarm')
plt.xlabel('Cohort Month')
plt.ylabel('Cohort Index')
plt.show()

"""**Insight**

1. **Retenção Inicial Alta:**

* As células na primeira linha de cada coorte (Índice 0) indicam a proporção de clientes que fizeram compras no mês de aquisição. Uma retenção inicial alta sugere que as estratégias de aquisição de clientes são eficazes.

2. **Queda Natural na Retenção:**

* É comum observar uma diminuição da retenção nos meses subsequentes. No entanto, coortes com quedas muito acentuadas podem indicar problemas na fidelização, como falta de incentivo para compras recorrentes.

3. **Coortes Consistentes:**

* Coortes com retenção consistente ao longo do tempo indicam um grupo de clientes engajados, que continuam comprando mesmo após o mês de aquisição. Esses clientes representam uma base valiosa e fiel.

4. **Sazonalidade:**

* Retenções mais altas em determinados períodos podem estar associadas a eventos sazonais, como datas festivas ou promoções. Isso sugere oportunidades para reforçar campanhas em momentos semelhantes.

5. **Coortes com Retenção Superior à Média:**

* Alguns meses podem apresentar retenções melhores em relação a outras coortes. Isso pode indicar o sucesso de campanhas específicas, melhorias no atendimento ao cliente ou maior atratividade dos produtos lançados naquele período.

# **8. Análise do Valor do Ciclo de Vida do Cliente (CLV)**

## **8.1. Cálculo do CLV (Valor do Ciclo de Vida do Cliente)**

**Descrição:**  O CLV (Customer Lifetime Value) mede o valor financeiro esperado que um cliente trará ao longo do relacionamento com a empresa. Este cálculo ajuda a identificar clientes mais valiosos e determinar onde investir esforços de retenção.
"""

import pandas as pd

# Passo 1: Criar a coluna Revenue (Receita Total por Transação)
df['Revenue'] = df['Quantity'] * df['UnitPrice']

# Passo 2: Receita média por transação (média de Revenue por cliente)
avg_revenue_per_order = df.groupby('CustomerID')['Revenue'].mean()

# Passo 3: Número médio de compras por cliente
avg_orders_per_customer = df.groupby('CustomerID')['InvoiceNo'].nunique()

# Passo 4: Calcular o CLV (Valor do Ciclo de Vida do Cliente)
clv = avg_revenue_per_order * avg_orders_per_customer

# Passo 5: Exibir os resultados
print("Valor do Ciclo de Vida do Cliente (CLV):")
clv.head()

"""## **8.2. Segmentação de Clientes com Base no CLV**

**Descrição:** A segmentação permite agrupar clientes de acordo com o CLV, facilitando a identificação de segmentos-chave como clientes VIP (muito valiosos) ou de baixo valor.
"""

# Passo 6: Segmentar clientes com base no CLV
clv_segment = pd.qcut(clv, 4, labels=['Low', 'Mid', 'High', 'VIP'])

# Exibir a distribuição dos clientes por segmento
print("Distribuição de Clientes por Segmento:")
clv_segment.value_counts().head()

"""## **8.3 Visualização da Distribuição de Segmentos**

**Descrição:** O gráfico ajuda a visualizar a quantidade de clientes em cada segmento, destacando onde está a maior parte da base de clientes.
"""

# Passo 7: Visualizar a distribuição de segmentos
clv_segment.value_counts().plot(kind='bar', figsize=(8, 5))
plt.title('Distribuição de Clientes por Segmento (CLV)')
plt.xlabel('Segmento')
plt.ylabel('Número de Clientes')
plt.show()

"""**Insight**

1. **Segmento Predominante:**

* Se o segmento Low ou Mid tiver a maior quantidade de clientes, isso indica que a maioria dos clientes gera um valor financeiro menor. Isso pode ser esperado em muitos negócios, mas também sugere uma oportunidade de aumentar o engajamento e o gasto médio desses clientes.

* Se o segmento High ou VIP for significativo, indica uma base sólida de clientes de alto valor, que são cruciais para a receita do negócio.

2. **Clientes VIP (Alta Contribuição):**

* Clientes no segmento VIP representam uma parcela menor da base, mas têm um impacto desproporcional na receita total. Esses clientes devem ser priorizados em campanhas de retenção e fidelização, como programas exclusivos e recompensas.

3. **Clientes de Baixo Valor:**

* O segmento Low inclui clientes que compram menos frequentemente e gastam pouco. Eles podem estar em risco de churn e precisar de campanhas de reativação ou incentivos para aumentar o gasto.

4. **Distribuição Balanceada:**

* Uma distribuição equilibrada entre os segmentos indica uma base diversificada de clientes. No entanto, o objetivo deve ser migrar clientes dos segmentos Low e Mid para High e VIP.

# **9. Conclusão**

A análise de CRM realizada com os dados de e-commerce forneceu insights fundamentais para compreender o comportamento dos clientes, otimizar estratégias de retenção e engajamento, e identificar oportunidades de crescimento no negócio.

Os resultados destacaram a importância dos clientes VIP para a receita total e a necessidade de ações específicas para reativar clientes de menor valor. Além disso, os produtos mais vendidos e as tendências sazonais nas vendas fornecem um direcionamento claro para campanhas promocionais e alocação de estoque.

Por meio da análise de coorte, foi possível identificar quedas naturais na retenção, mas também destacar grupos de clientes que continuam engajados, demonstrando o impacto positivo de campanhas específicas. A segmentação baseada no CLV ajudou a classificar os clientes em diferentes categorias, permitindo priorizar recursos para aqueles que geram maior retorno financeiro.

Com essas informações, recomenda-se:

* Investir em programas de fidelidade e campanhas personalizadas para clientes de alto valor.

* Realizar campanhas de reativação para clientes com baixo engajamento.

* Planejar promoções estratégicas em períodos de alta demanda e sazonalidade.

* Continuar monitorando os dados para avaliar o impacto das ações e ajustar as estratégias conforme necessário.


Esse conjunto de análises fornece uma base sólida para decisões orientadas por dados, garantindo crescimento sustentável e melhoria na experiência do cliente.
"""